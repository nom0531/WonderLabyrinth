<!DOCTYPE html>
    <html>
		https://dulcet-gumdrop-451e7d.netlify.app/
		
    <head>
        <meta charset="UTF-8">
        <title>WonderLabyrinth</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="wonderlabyrinth">WonderLabyrinth</h1>
<lead>
河原学園電子ビジネス専門学校 <br>
ゲームクリエイター科 1年 野村華生
</lead><br><br>
<p><img src="https://user-images.githubusercontent.com/122655553/216737056-41b0fe0d-10a6-462c-be1a-41d8cadb5fb0.png" alt="図1" title="WonderLabyrinth タイトル画面"><br></p>
<h2 id="自己紹介">自己紹介</h2>
<p>[プロフィール]<br>
 2003年5月31日生まれ。<br>
 趣味はイラストや写真撮影、ゲーム等。</p>
<p>[検定取得状況] ※<br>
 情報処理技術者能力認定試験 3級<br>
 C言語プログラミング能力認定試験 3級<br>
 Photoshop®クリエイター能力認定試験 スタンダード<br>
 (※2023年2月現在の獲得状況です。)<br><br></p>
<h2 id="目次-">目次 <br></h2>
<p><a href="https://github.com/nom0531/WonderLabyrinth/blob/main/README.md#1%E4%BD%9C%E5%93%81%E6%A6%82%E8%A6%81">1.作品概要</a> <br>
 1.1 作品紹介<br>
 1.2 内部構成<br><br>
<a href="https://github.com/nom0531/WonderLabyrinth/blob/main/README.md#2%E6%93%8D%E4%BD%9C%E8%AA%AC%E6%98%8E">2.操作説明</a> <br>
 2.1 基本操作<br><br>
<a href="https://github.com/nom0531/WonderLabyrinth/blob/main/README.md#3%E6%8A%80%E8%A1%93%E8%AA%AC%E6%98%8E">3.技術説明</a> <br>
 3.1 会話するNPC<br>
 3.2 移動・当たり判定の処理<br>
 3.3 ステージのランダム生成<br><br>
<a href="https://github.com/nom0531/WonderLabyrinth/blob/main/README.md#4%E3%81%93%E3%81%A0%E3%82%8F%E3%82%8A%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88">4.ゲーム内のこだわり</a> <br>
 4.1 誰にでもわかるUI<br>
 4.2 ステージのテクスチャ<br><br></p>
<h2 id="1作品概要">1.作品概要</h2>
<p>◆◇ <strong>1.1 作品紹介</strong> ◇◆<br></p>
<p><a href="https://youtu.be/NlRZ1-RVJbg" title="https://youtu.be/NlRZ1-RVJbg">【作品紹介】Wonder Labyrinth</a><br></p>
<p>  三人称視点の1人用ターン制アクションゲームです。<br>
  時間制限内に体力を保ちつつ、敵を倒しながらステージを進んでいきます。<br></p>
<p>  プレイヤーは名もなき冒険家となり、危険な迷宮に挑む最中に出会った妖精、<br>
  「アル」を相棒として、ともに迷宮の深部を目指します。<br><br></p>
<p>◆◇ <strong>1.2 内部構成</strong> ◇◆<br></p>
<p>[使用ゲームエンジン]<br>
 学校内製エンジンを使用 <br>
 (※一部改造箇所あり。<a href="https://github.com/nom0531/WonderLabyrinth/blob/main/README.md#3%E6%8A%80%E8%A1%93%E8%AA%AC%E6%98%8E">3.技術説明</a>の &quot;<strong>3.1 会話するNPC</strong>&quot; にて詳しく触れています。)</p>
<p>[使用ツール] <br>
 Visual Studio 2022 <br>
 3ds Max 2022 <br>
 Adobe Photoshop 2022 <br>
 FireAlpaca64 <br></p>
<p>[使用楽曲サイト] <br>
 <a href="https://audiostock.jp/mypage/welcome/customer" title="https://audiostock.jp/mypage/welcome/customer">AudioStock</a> 様 <br>
 <a href="https://dova-s.jp" title="https://dova-s.jp">DOVA-SYNDROME</a> 様 <br></p>
<p>[使用言語] <br>
 C++ <br></p>
<p>[開発環境] <br>
 Windows11 <br></p>
<p>[制作人数] <br>
 1人 <br></p>
<p>[開発期間] <br>
 2022/09～2022/01 <br></p>
<p>[対応コントローラー]<br>
 Logitech Gamepad F310 <br>
 Microsoft Windows11 キーボード</p>
<p>[備考] <br>
 第11回ゲームコンペティション プレイアブル部門 応募作品 <br><br></p>
<h2 id="2操作説明">2.操作説明</h2>
<p>◆◇ <strong>2.1 基本操作</strong> ◇◆<br></p>
<p><img src="https://user-images.githubusercontent.com/122655553/213868336-da84f4b4-c8a9-49e5-82e5-40c7954bb47d.png" alt="図2.1.1" title="操作説明"><br><br></p>
<p>[ゲーム内操作（ゲームプレイ時の主な操作）] <br>
 十字キー　 　 …　キャラクターの移動 <br>
 Lスティック　…　カメラの移動 <br>
 Xボタン　　　…　カメラの上下切り替え <br>
 Aボタン　　　…　次のテキストを表示(会話時のみ有効) <br>
 Bボタン　　　…　攻撃 <br>
 STARTボタン　…　ヒントを聞く <br></p>
<p>[システム操作（タイトル、操作説明など）] <br>
 十字キー　 　 …　ページ、選択項目の切り替え <br>
 Aボタン　　　…　決定 <br>
 Bボタン　　　…　キャンセル <br><br></p>
<h2 id="3技術説明">3.技術説明</h2>
<p>◆◇ <strong>3.1 会話するNPC</strong> ◇◆<br></p>
<p><img src="https://user-images.githubusercontent.com/122655553/214467041-15f1530a-3ec1-4871-8b7a-d134bcdc41a6.png" alt="図3.1.1" title="テキストの出力途中のスクリーンショット">
<img src="https://user-images.githubusercontent.com/122655553/214469059-aac2ed1f-52b1-431d-8d04-03bc04e39518.png" alt="図3.1.2" title="最終的な出力状態"><br><br></p>
<p> 本作品ではエンジンを改造し、テキストが出力される仕様を作成しています。 <br>
 出力は1文字ずつ出力され、出力が終わったかどうかを判定して次のテキストを表示します。 <br></p>
<p> エンジン内のFontRender.cpp 及び FontRender.hを改造して作成しました。 <br>
 ※サンプルコード内の関数、及び処理の流れとは多少異なります。 <br></p>
<p> テキストを出力する流れとしては以下の通りです。 <br>
 1. 表示したいテキストを関数（関数名等はサンプルコードにて）で指定。 <br>
 2. for文を回してテキストを予備の配列に格納。 <br>
 3. テキストを表示する関数を呼び出し、出力できるようにする。 <br>
 4. 指定した表示間隔とタイマーの現在値を比較して、文字を１文字ずつ出力する。 <br></p>
<details>
	<summary>3.1 サンプルコード</summary><div>	
<pre><code>	wchar_t m_text_stock[256] = L&quot;&quot;;	// 予備テキスト
	float m_sendText_Interval = 0;		// テキスト送りのインターバルフレーム(間隔)
	float m_sendText_Timer = 0;		// テキスト送りタイマー
	bool m_sendFlag = false;		// メッセージ送り処理のフラグ
	int m_sendText_Len = 0;			// 予備テキストの文字数
	int m_sendText_NowLen = 0;		// 現在の文字数
	

	// 1. 表示するテキストを指定する。
	void FontRender::SetSendText(const wchar_t* text, const float&amp; Interval) 
	{
		// 2. 予備テキストの文字数に設定したテキストの文字数を格納。
		m_sendText_Len = (int)wcslen(text);	// 文字数を取得
		// 文字数分for文を回す。
		for (int n = 0; n &lt; m_sendText_Len + 1; n++) {
			// 予備テキスト内に指定したテキストの中身を代入する。
			m_text_stock[n] = text[n];
		}

		// 設定
		// クラス内の変数に引数の Interval を代入する。
		m_sendText_Interval = Interval;
		// タイマーをリセット
		m_sendText_Timer = 0;
		// メッセージ送りフラグを true にして出力できるようにする。
		m_sendFlag = true;
		// 0 の時点で中身を出力してしまうので -1 で出力しないようにする。
		m_sendText_NowLen = -1;
	}
	
	// 3. 指定したテキストを表示する。
	bool FontRender::SendTextUpdate(const float addTime) 
	{
		// メッセージ送りフラグが true なら更新処理を行う。
		if (m_sendText == true) {
			// 4. 指定した表示間隔とタイマーの現在値を比較して、文字を１文字ずつ出力する。
			// fpsをタイマーに加算する
			m_sendText_Timer += addTime;
			// テキストを表示する間隔がタイマーの数値以下のとき
			if (m_sendText_Interval &lt;= m_sendText_Timer) {

				// NowLenの値を +1 し、次の文字を表示する。
				m_sendText_NowLen++;

				// 移植
				// 現在のNowLen +1 回分for文を回す。
				for (int n = 0; n &lt; m_textSend_NowLen + 1; n++) {
					// 予備テキストを代入
					m_text[n] = m_text_stock[n];
				}	

				// 後始末
				// タイマーをリセット。
				m_sendText_Timer = 0.0f;
				// 現在の文字数が予備テキストの文字数以上の時
				if (m_sendText_NowLen &gt;= m_sendText_Len) {
					m_sendFlag = false;		// 終了
				}

				// true を返す。
				return true;
			}

			// テキストを表示する間隔がタイマーの数値以上のとき
			// false を返す。
			return false;
		}
	}
</code></pre>
</div></details>
<br><br>
<p>◆◇ <strong>3.2 移動、当たり判定の処理</strong> ◇◆<br></p>
<p><img src="https://user-images.githubusercontent.com/122655553/214481415-3d17fbd6-6223-49a2-8259-47cd7706783a.png" alt="図3.2.1" title="チュートリアルの盤面を上から見たスクリーンショット"><br><br></p>
<p> 本作品の移動処理、当たり判定の処理は配列を用いて <br>
 プレイヤーキャラクター、エネミー問わず同じ処理を行っています。 <br></p>
<p> それぞれがステージのマス数分の二次元配列を有しており、 <br>
 そのステージ上での自身の現在の位置（1）を情報として持っています。 <br></p>
<p> 例えば上記の画像とき、プレイヤーキャラクター（中央下）は、 <br><br></p>
<table>
<thead>
<tr>
<th>行/列</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<br>
&emsp;という情報を持っていることになります。 <br>
&emsp;この配列を基にして、移動した後の座標を決定し、当たり判定を作成しています。 <br>
<p> 配列の情報を切り替える処理としては以下の流れになります。 <br>
 1. オブジェクトが移動。 <br>
 2. 移動した方向に配列の中身に 1 を代入する。 <br>
 3. 移動したので元々入っていた配列の中身を0にする。 <br></p>
<details>
	<summary>3.2 サンプルコード</summary><div>	
<pre><code>	float moveSpeed = 50.0f;	// 移動速度

	// 1. オブジェクトが移動。
	if (g_pad[0]-&gt;IsTrigger(enButtonUp)) {
		// 現在の2D座標（二次元配列）を代入する
		Vector2 move = position2D;
		// move を移動した後の値にする。
		move.y -= 1.0f;			

		// 動こうとした方向（今回は上方向）に動けるとき。
		if (IsMove(move) == true) {
			// 上方向の情報に移動速度を加算。
			position.z += moveSpeed;
			// ステージのマス数分for文を回す。
			for (int i = 0; i &lt; num-&gt;stageNum; i++) {
				for (int j = 0; j &lt; num-&gt;stageNum; j++) {
					// 2. 移動した方向の配列の中身に 1 を代入する。
					// 現在の座標（1）を見つけたとき
					if (position_stage[i][j] == 1) {

						// 3. 移動したので元々入っていた配列の中身を0にする。
						position_stage[i][j] = 0;
						// 移動した方向に 1 を代入する。
						position_stage[i - 1][j] = 1;
						// 2D座標（二次元配列）の値を移動後の値にする。
						position2D.y -= 1.0f;

						return;
					}
				}
			}
		}
	}
</code></pre>
</div></details>
<p> 「上記のサンプルコードを実行した」と考えた際の二次元配列の内容は、以下のようになります。<br><br></p>
<table>
<thead>
<tr>
<th>行/列</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<br>
&emsp;先ほどの配列と違い、1（現在の座標）が移動しているのがわかるでしょうか。<br>
&emsp;実際の処理では、サンプルコードと同じように、上下左右の四方の計算を行っています。<br>
<p> このようにして現在の座標を決定し、当たり判定の処理を行っています。<br><br></p>
<p>◆◇ <strong>3.3 ステージのランダム生成</strong> ◇◆<br></p>
<p><img src="https://user-images.githubusercontent.com/122655553/213916571-711b4e4a-fc53-4196-a1e8-3bcf3321fce4.png" alt="図3.3.1" title="1層目のステージ">
<img src="https://user-images.githubusercontent.com/122655553/213916575-b57d40c3-cce9-426e-afe2-b2bc35a053a9.png" alt="図3.3.2" title="2層目のステージ"><br><br></p>
<p> 本作品のステージは、一部を除き、9×9のマスで構成されています。 <br><br>
 マスと前述しました通り、ステージのモデルは一つに見えますが、 <br>
 内部的には全く別のオブジェクトで構成されています。 <br><br>
 [8][8]の二次元配列としてステージの情報を渡し、その情報を元にして、 <br>
 対応するモデルを読み込むことでステージを組み立てています。 <br><br>
<img src="https://user-images.githubusercontent.com/122655553/213916588-924eff1b-a985-4ad6-9d30-c6653c6fba5d.png" alt="図3.3.3" title="実際に使用したステージのモデル"> <br><br>
 そのようにしてステージを作成しているため、 <br></p>
<p> 1. あらかじめいくつかのステージを作成。 <br>
 2. プログラムコード内で乱数を出し、Switch文で振り分ける。 <br>
 3. 対応するステージの情報に差し替えて出力する。 <br>
 ・・・という形でランダム生成を行っています。</p>
<details>
	<summary>3.3 サンプルコード</summary><div>	
<pre><code>		int stageNum = 2;			// 2次元配列の行と列の値。

		// 1. あらかじめいくつかのステージを作成。
		// 元々のステージのデータ。
		// 本作では配列内に格納している値でテクスチャを指定しています。
		int stage[2][2] = {
		{ 0,0 },
		{ 0,0 },
		};

		// 帰ってきた値が 0 の時このデータを代入する。
		int stage_0[2][2] = {
		{ 0,1 },
		{ 1,0 },
		};

		// 帰ってきた値が 1 の時このデータを代入する。
		int stage_1[2][2] = {
		{ 1,1 },
		{ 1,1 },
		};

		int stageState = rand() % 2;		// 0~1 でランダムな値を返す。			

		2.プログラムコード内で乱数を出し、Switch文で振り分ける。
		// ステージ情報を代入する。
		switch (stageState) {
		case 0:
			// 3. 対応するステージの情報に差し替えて出力する。
			for (int j = 0; j &lt; stageNum; j++) {
				for (int i = 0; i &lt; stageNum; i++) {
					stage[j][i] = stage_0[j][i];
				}
			}
			break;
		case 1:
			// 3. 対応するステージの情報に差し替えて出力する。
			for (int j = 0; j &lt; stageNum; j++) {
				for (int i = 0; i &lt; stageNum; i++) {
					stage[j][i] = stage_1[j][i];
				}
			}

			break;
		}
</code></pre>
</div></details>
<p> この後は格納されている値を見て、テクスチャを決定する処理を行っています。 <br><br>
 ゲーム内ではステージのランダム生成の仕様に合わせ、場合に応じたテクスチャとBGMを適応させています。 <br>
 詳しくは <a href="https://github.com/nom0531/WonderLabyrinth/blob/main/README.md#4%E3%81%93%E3%81%A0%E3%82%8F%E3%82%8A%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88">4.ゲーム内のこだわり</a>の &quot;<strong>4.2 ステージのテクスチャ</strong>&quot; にて詳しく触れています。 <br><br></p>
<h2 id="4ゲーム内のこだわり">4.ゲーム内のこだわり</h2>
<p>◆◇ <strong>4.1 誰にでも伝わるようなUI</strong> ◇◆<br></p>
<p><img src="https://user-images.githubusercontent.com/122655553/213916423-6576f885-0525-4e8d-9da6-fdbf708e1026.png" alt="図4.1.1" title="ゲーム内で使用したUI一覧"> <br><br></p>
<p> 似通った色、フォントを使用することで、全体で統一感を持たせました。 <br><br>
 また、作品を通して柔らかなイメージを持たせるために、 <br>
 殆どのUIを丸みのあるデザインにしています。 <br><br>
 ゲーム本編にて画面に表示されているアイコンは、 <br>
 できる限り文字を使用せず、直感的に伝わるデザインを施しました。 <br><br></p>
<p><img src="https://user-images.githubusercontent.com/122655553/213916498-632df5ec-2178-495d-ab86-fc4e8d457401.png" alt="図4.1.2" title="ゲーム内で使用したアイテムのゲージ">
<img src="https://user-images.githubusercontent.com/122655553/213916501-5eb41197-cb4c-4b68-b0d7-60199b983daa.png" alt="図4.1.3" title="ゲーム内で登場するアイテム"><br><br></p>
<p> それ以外にも、関連性を紐づけしやすくなるよう同じ色を使用する、<br>
 体力は赤、アイテムは青…など、イメージしやすい色を使用する、などの工夫も行いました。<br><br></p>
<p>◆◇ <strong>4.2 ステージのテクスチャ</strong> ◇◆<br><br></p>
<p><img src="https://user-images.githubusercontent.com/122655553/213963486-bad5e8da-445b-4671-9359-ae5cc04ddacb.png" alt="図4.2.1" title="1層目のスクリーンショット">
<img src="https://user-images.githubusercontent.com/122655553/213963495-45c104d4-72b3-4769-885f-b0bd7c0a3ad4.png" alt="図4.3.2" title="10層目のスクリーンショット"><br><br></p>
<p> 本作品ではゴールする（奥の赤いマスにたどり着く）度に、右上の階層数が1つずつ加算されていきます。 <br>
 この階層数を多くするために沢山進む、というのがこのゲームの目的になっています。<br><br>
 そのため、より階層を進んでいるように感じられるように<br>
 階層数が「5層」増えるごとにステージのテクスチャが変更されるようにしています。 <br><br></p>
<p><img src="https://user-images.githubusercontent.com/122655553/213963507-7cb18f85-abfc-4faa-87f7-a48615e09cbb.png" alt="図4.2.3" title="学校内製エンジンを使用したテクスチャ①">
<img src="https://user-images.githubusercontent.com/122655553/213963512-e9ebb04e-fdd8-4fad-94da-82bc02298760.png" alt="図4.2.4" title="学校内製エンジンを使用したテクスチャ②"> <br><br></p>
<p> ステージそのもののテクスチャの他にも、背景や環境光なども変更しています。 <br><br>
 テクスチャ②ではステージのイメージが「洞窟」ということで、&quot; 探索している &quot;という印象を持たせるため、 <br>
 また、プレイヤーが操作キャラクターを見失わないようにするためにポイントライトを使用しています。 <br></p>
<p><a href="https://github.com/nom0531/WonderLabyrinth#%E7%9B%AE%E6%AC%A1-">目次へ戻る</a></p>

        
        
    </body>
    </html>